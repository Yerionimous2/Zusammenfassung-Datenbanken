\documentclass{article}

\input{config.tex}

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[width=0.3\textwidth]{Uni Logo.png} 
    \vspace*{2cm}
    
    {\Large\bfseries Datenbanken Zusammenfassung\par}
    \vspace{1.5cm}
    
    \textbf{Peter Minor}\\
    Sommersemester 2025
    
    \vfill    
    \vspace{1.5cm}
    {\large \today\par}
\end{titlepage}

\tableofcontents

\newpage
\section{Kapitel 1: Einführung}
Sehr viel Geyappe über Datenbanken und Entwurfsmodelle, später.

\section{Kapitel 2: Datenbank-Modellierung}

\begin{block}{Modell}
Ein Modell ist ein abstrahiertes Abbild der Realität. Es hilft beim Verständnis, bei der Kommunikation und Simulation komplexer Sachverhalte. In der Datenbankmodellierung wird zwischen konzeptuellen, logischen und physischen Modellen unterschieden.
\end{block}

\subsection*{Entity-Relationship-Modell (ER)}

\begin{block}{Entitätstyp}
Ein Entitätstyp (auch Objekttyp) ist eine Klasse gleichartiger Objekte. Darstellung im ER-Diagramm: Rechteck.
\end{block}

\begin{block}{Attribut}
Ein Attribut beschreibt eine Eigenschaft eines Entitätstyps. Darstellung: Ellipse. Attribute können einfach, zusammengesetzt, mehrwertig oder berechnet sein.
\end{block}

\begin{block}{Beziehungstyp (Relationship)}
Ein Beziehungstyp stellt eine Relation zwischen Entitäten dar. Darstellung: Raute. Die Kardinalität (1:1, 1:n, m:n) beschreibt die Anzahl möglicher Zuordnungen.
\end{block}

\begin{block}{Schlüssel}
Ein Schlüssel ist ein Attribut (oder eine Attributkombination), das jede Entität eindeutig identifiziert. Starke Entitäten haben eigene Schlüssel; schwache Entitäten benötigen eine identifizierende Beziehung zu einer starken Entität.
\end{block}

\begin{block}{Partizipation}
Beschreibt, ob eine Entität zwingend an einer Beziehung teilnehmen muss:
\begin{itemize}
  \item \textbf{totale Partizipation}: jede Entität muss beteiligt sein
  \item \textbf{partielle Partizipation}: Beteiligung ist optional
\end{itemize}
\end{block}

\begin{block}{Spezialisierung \& Generalisierung (EER)}
\begin{itemize}
  \item \textbf{Spezialisierung}: Zerlegung eines Supertyps in Subtypen
  \item \textbf{Generalisierung}: Vereinigung ähnlicher Entitätstypen zu einem Supertyp
\end{itemize}
\end{block}

\begin{center}
\begin{tikzpicture}[node distance=2cm, every node/.style={scale=0.85}]
  % Entity types
  \node[draw, rectangle] (Student) {Student};
  \node[draw, rectangle, right=5cm of Student] (Vorlesung) {Vorlesung};
  \node[draw, rectangle, above=3cm of Vorlesung] (Professor) {Professor};

  % Attributes
  \node[draw, ellipse, below=1.2cm of Student] (MatrNr) {MatrNr};
  \node[draw, ellipse, below left=1.2cm and 0.5cm of Student] (SName) {Name};

  \node[draw, ellipse, below=1.2cm of Vorlesung] (VorlNr) {VorlNr};
  \node[draw, ellipse, below right=1.2cm and 0.5cm of Vorlesung] (Titel) {Titel};

  \node[draw, ellipse, above left=1.2cm and 0.5cm of Professor] (PersNr) {PersNr};
  \node[draw, ellipse, above=1.2cm of Professor] (PName) {Name};

  % Relationship types
  \node[draw, diamond, below=0.8cm of $(Student)!0.5!(Vorlesung)$] (hoert) {hört};
  \node[draw, diamond, right=2cm of Professor] (liest) {liest};

  % Connections
  \draw (Student) -- (hoert);
  \draw (Vorlesung) -- (hoert);

  \draw (Professor) -- (liest);
  \draw (Vorlesung) -- (liest);

  \draw (Student) -- (MatrNr);
  \draw (Student) -- (SName);

  \draw (Vorlesung) -- (VorlNr);
  \draw (Vorlesung) -- (Titel);

  \draw (Professor) -- (PersNr);
  \draw (Professor) -- (PName);
\end{tikzpicture}
\end{center}

\section{Kapitel 3: Das relationale Datenmodell}

\begin{block}{Relation}
Eine Relation ist eine Tabelle mit Attributen (Spalten) und Tupeln (Zeilen). Sie basiert auf dem mathematischen Konzept einer Menge von Tupeln.
\end{block}

\begin{block}{Primärschlüssel}
Ein Attribut oder Attributkombination, die ein Tupel eindeutig identifiziert.
\end{block}

\begin{block}{Fremdschlüssel}
Ein Attribut, das auf den Primärschlüssel einer anderen Relation verweist und referentielle Integrität sicherstellt.
\end{block}

\subsection*{Relationale Algebra}

\begin{block}{Selektion ($\sigma$)}
Filtert Tupel, die eine bestimmte Bedingung erfüllen. Beispiel:
\[
\sigma_{Note \geq 4}(\text{Pruefungen})
\]
\end{block}

\begin{block}{Projektion ($\pi$)}
Reduziert die Anzahl der Attribute. Beispiel:
\[
\pi_{Name, MatrNr}(\text{Studierende})
\]
\end{block}

\begin{block}{Vereinigung $\cup$ Schnitt $\cap$ Differenz $-$}
Klassische Mengenoperationen für Relationen mit gleichem Schema.
\end{block}

\begin{block}{Kartesisches Produkt ($\times$)}
Kombiniert zwei Relationen durch paarweise Tupelkombination.
\end{block}

\begin{block}{Join ($\bowtie$)}
Verknüpft zwei Relationen über gemeinsame Attribute. Spezialformen:
\begin{itemize}
  \item natürlicher Join
  \item theta-Join
  \item equi-Join
\end{itemize}
\end{block}

\begin{block}{Umbenennung ($\rho$)}
Benennung einer Relation oder ihrer Attribute neu, z.B. zur besseren Lesbarkeit von Ausdrücken.
\end{block}


Beispielhafte Relationen:
\begin{itemize}
  \item \textbf{Student}(\underline{MatrNr}, Name)
  \item \textbf{Professor}(\underline{PersNr}, Name)
  \item \textbf{Vorlesung}(\underline{VorlNr}, Titel)
  \item \textbf{hört}(\underline{MatrNr}, \underline{VorlNr}) \\
        Fremdschlüssel: MatrNr $\rightarrow$ Student, VorlNr $\rightarrow$ Vorlesung
  \item \textbf{liest}(\underline{PersNr}, \underline{VorlNr}) \\
        Fremdschlüssel: PersNr $\rightarrow$ Professor, VorlNr $\rightarrow$ Vorlesung
\end{itemize}

\section{Kapitel 4: Relationale Entwurfstheorie}

\begin{block}{Funktionale Abhängigkeit}
Eine Attributmenge $\alpha$ bestimmt eine andere Attributmenge $\beta$, geschrieben als:
\[
\alpha \rightarrow \beta
\]
gilt genau dann, wenn für alle Tupel $t_1$, $t_2$ gilt: $t_1[\alpha] = t_2[\alpha] \Rightarrow t_1[\beta] = t_2[\beta]$
\end{block}

\begin{block}{Schlüssel und Superschlüssel}
\begin{itemize}
  \item \textbf{Superschlüssel:} $\alpha$ ist Superschlüssel, wenn $\alpha \rightarrow R$
  \item \textbf{Kandidatenschlüssel:} Minimaler Superschlüssel
\end{itemize}
\end{block}

\begin{block}{Ziel der Normalisierung}
Die Normalisierung dient dazu, Redundanzen zu vermeiden und Anomalien (Einfüge-, Update-, Löschanomalien) zu verhindern. Dazu wird ein Relationenschema anhand funktionaler Abhängigkeiten in wohldefinierte Formen überführt.
\end{block}

\begin{block}{Überblick über die Normalformen}
\begin{itemize}
  \item \textbf{1NF (erste Normalform):} 
    Alle Attributwerte sind atomar (nicht weiter teilbar).
  \item \textbf{2NF (zweite Normalform):} 
    1NF erfüllt + jedes Nicht-Schlüsselattribut ist voll funktional abhängig vom gesamten Primärschlüssel.
  \item \textbf{3NF (dritte Normalform):} 
    2NF erfüllt + keine transitiven Abhängigkeiten von Nicht-Schlüsselattributen.
  \item \textbf{BCNF (Boyce-Codd Normalform):} 
    Für jede nicht-triviale funktionale Abhängigkeit $\alpha \rightarrow \beta$ gilt: $\alpha$ ist ein Superschlüssel.
\end{itemize}
\end{block}

\begin{block}{Vorgehen zur Normalisierung}
\begin{enumerate}
  \item Ermittele alle funktionalen Abhängigkeiten (FDs).
  \item Bestimme alle Schlüsselkandidaten.
  \item Prüfe die aktuelle Normalform.
  \item Zerlege die Relation bei Verstoß in mehrere Relationen:
  \begin{itemize}
    \item Zerlege so, dass jede FD in einer Relation vollständig erfüllt wird.
    \item Erhalte dabei die Verlustfreiheit und Abhängigkeitserhaltung.
  \end{itemize}
\end{enumerate}
\end{block}

\begin{block}{Beispiel: Normalisierung auf 3NF}
Gegeben sei folgende Relation:
\[
R(\underline{MatrNr}, Name, Studiengang, Fakultaet)
\]
mit den funktionalen Abhängigkeiten:
\begin{align*}
\text{F1: } & \text{MatrNr} \rightarrow \text{Name, Studiengang, Fakultaet} \\
\text{F2: } & \text{Studiengang} \rightarrow \text{Fakultaet}
\end{align*}

\textbf{Analyse:}
\begin{itemize}
  \item F1: MatrNr ist ein Schlüsselkandidat.
  \item F2: transitive Abhängigkeit: MatrNr $\rightarrow$ Studiengang $\rightarrow$ Fakultaet
  \item $\Rightarrow$ Verstoß gegen 3NF.
\end{itemize}

\textbf{Zerlegung in 3NF:}
\begin{itemize}
  \item $R_1(\underline{MatrNr}, Name, Studiengang)$
  \item $R_2(\underline{Studiengang}, Fakultaet)$
\end{itemize}

\textbf{Ergebnis:} Beide Relationen sind in 3NF, keine Redundanz, keine Anomalien.
\end{block}

\begin{block}{Anomalien}
Anomalien treten auf, wenn Relationen schlecht strukturiert sind – meist durch Redundanz und fehlende Trennung von unabhängigen Daten. Es gibt drei Hauptarten:
\begin{itemize}
  \item \textbf{Einfügeanomalie:} Daten können nicht eingefügt werden, ohne andere zu erzeugen
  \item \textbf{Updateanomalie:} Inkonsistenz bei mehrfacher Speicherung derselben Information
  \item \textbf{Löschanomalie:} Verlust nützlicher Informationen durch Löschung eines Tupels
\end{itemize}
\end{block}

\section{Kapitel 5: SQL - Structured Query Language}

Wir befinden uns in der Datenbank-Installation, also im Physischen Schemaentwurf.

\begin{block}{Historie}
  \begin{itemize}
    \item 1974: SEQUEL von IBM, Implementierung für System R
    \item 1983: SQL ist der Standard geworden
    \item 1986: SQL-86, bzw. SQL 1 $\Rightarrow$ erster ANSI und ISO-Standard
    \item 1992: SQL 2, deutliche Erweiterungen im Standard
    \item Weitere Revisionen:2000(SQL 3), 2003, 2006, 2008, 2011, 2016, 2023
  \end{itemize}
\end{block}

SQL dient als verschiedene Sprachen:
\begin{itemize}
  \item VDL, DDL, SDL zur Definition von Datenbanken
  \item DML(Datenmanipulationssprache), DCL(Datenkontrollsprache) zum Zugriff auf Datenbanken
\end{itemize}
SQL-Befehle:
\begin{center}
  \begin{tabular}{|p{4cm}|p{7cm}|}
    \hline
    \textbf{Befehl} & \textbf{Beschreibung} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DDL(Datendefinition)} \\
    \hline
    \texttt{CREATE SCHEMA} & Erstellt ein neues Schema in der Datenbank. \\
    \hline    
    Beispiel & \texttt{create schema Unternehmen authorization JSmith create table Projekt;} \\
    \hline
    Einfacher: & \texttt{PID int not null primary key,} \\
    & geht aber leider nicht mit zusammengesetzten Schlüsseln. \\
    \hline
    \texttt{CREATE Table} & Erstellt eine neue Tabelle im Schema. \\
    \hline
    Beispiel & \texttt{create table Projekt (} \\ & \texttt{PID int not null,} \\ & \texttt{Name varchar(50) not null, } \\ & \texttt{primary key(PID));} \\
    \hline
    \texttt{ALTER Table} & ändert die angegebene Tabelle. \\
    \hline
    \multicolumn{2}{|p{11cm}|}{Es gibt noch andere Verwendungen für \texttt{alter:}} \\
    \texttt{alter database} & ändert Eigenschaften der Datenbank. \\
    \texttt{alter view} & ändert die Definition einer Sicht \\
    \texttt{alter index} & modifiziert einen Index \\
    \texttt{alter user/role} & ändert die Rollen eines Benutzers \\
    \hline
    \texttt{Add} & Fügt eine Spalte zu einer Tabelle hinzu \\
    \hline
    Beispiel & \texttt{alter table Angestellte} \\
    & \texttt{ add foreign key (Abt) references Abteilung(Nummer);} \\
    \hline
    \texttt{drop} & Löscht das angegebene Objekt. Kann auf Schemen, Tabellen, Sichten, Constraints und Spalten angewendet werden. \\
    \hline
    Beispiel & \texttt{drop table Arbeitszeiten;} \\
    \hline
    \texttt{rename} & Ändert den Namen einer Tabelle \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DML(Datenmanipulation und -abfrage)} \\
    \hline
    \texttt{select [..] from} & Wählt die gegebenen Spalten aus der Tabelle aus und gibt sie zurück \\
  \end{tabular}
\end{center}
SQL-Keywords:
\begin{center}
  \begin{tabular}{|p{4cm}|p{7cm}|}
    \hline
    \textbf{Keyword} & \textbf{Beschreibung} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DDL(Datendefinition)} \\
    \hline
    \texttt{not null} & Attribut darf nicht leer sein. \\
    \hline
    \texttt{primary key} & Attribut ist Primärschlüssel der Tabelle. \\
    \hline
    \texttt{unique} & Attributwerte müssen eindeutig sein. \\
    \hline
    \texttt{check} & Ermöglicht komplexere Einschränkungen \\
    \hline
    \texttt{cascade} & ? \\
    \hline
    \texttt{set null} & Setzt die Referenz auf null \\
    \hline
    \texttt{set default} & Setzt die Referenz auf den Default-Wert \\
    \hline
    \texttt{No Action/Restrict} & ? \\
    \hline
    Beispiel & Constraints beispiel? \\
    \hline
    \texttt{foreign key} & Attribut verweist auf Primärschlüssel einer anderen Tabelle. \\
    \hline
    \texttt{references} & Definiert die referenzierte Tabelle und Spalte für den Fremdschlüssel. \\
    \hline
    Beispiel: & \texttt{foreign key (PID) references Projekt(PID)} \\
    \hline
    \texttt{to\_number} oder \texttt{to\_char} & Konvertiert Datentypen, z.B. von String zu Zahl oder umgekehrt. \\
    \hline
    Date, Time, Datetimeoffset, interval, year, day, second? & \\
    \hline
    \texttt{where} & filtert nach Bedingungen \\
    \hline
    Beispiel & \texttt{select * from Klausur where Note <= 4;} \\
    \hline
    \texttt{and} & Verknüpft Bedingungen, alle müssen erfüllt sein \\
    \hline
    \texttt{or} & Verknüpft Bedingungen, mindestens eine muss erfüllt sein \\
    \hline
    \texttt{order by} & Sortiert die Ergebnisse nach den angegebenen Spalten \\
    \hline
    \texttt{Asc} bzw. \texttt{desc} & Sortiert aufsteigend bzw. absteigend, Asc ist der Standardwert \\
    \hline
    Beispiel & \texttt{select * from Klausur order by Note desc;} \\
    \hline
    \texttt{group by} & Gruppiert die Ergebnisse nach den angegebenen Spalten \\
    \hline
    Beispiel & \texttt{select * from Belegung group by KursID;} \\
    \hline
    \texttt{distinct} & Entfernt doppelte Einträge aus dem Ergebnis \\
    & Aber ist teuer und braucht man nicht unbedingt.\\
    \hline
    Beispiel & \texttt{select distinct Alter from Student;} \\
    \hline
    \texttt{as} & Benennt die Spalte um \\
    Beispiel & \texttt{select Name as StudentName from Student;} \\
    \hline
    \texttt{count} & Zählt die Anzahl der Tupel \\
    \hline
    \texttt{sum} & Summe der Werte der Tupelattribute \\
    \hline
    \texttt{min} & kleinstes Tupelattribut \\
    \hline
    \texttt{max} & größtes Tupelattribut \\
    \hline
    \texttt{avg} & durschschnittlicher Wert der Tupelattribute \\
    \hline
    Beispiel & \texttt{select max(Gehalt) from Angestellte;} \\
    \hline
    Wie interagieren die mit group by? & Folie 63-65, Kapitel 5 \\
    \hline
  \end{tabular}
\end{center}

\begin{block}{SQL als DDL}
  \begin{itemize}
    \item Schema, Tabellen, Datentypen, Constraints definieren
    \item Strukturelle Änderungen mittels \texttt{drop}, \texttt{alter}
    \item SCHEMA:
    \begin{itemize}
      \item Namensraum in DB
      \item Hat eindeutigen Namen
      \item Hat Autorisierungsbezeichner
      \item Beschreibt jedes im Schema enthaltene Objekt
      \begin{itemize}
        \item Relationen
        \item Wertebereiche
        \item Restriktionen
        \item Sichten
        \item Zugriffsrechte
      \end{itemize}
    \end{itemize}
    \item \texttt{information\_schema} enthält Metadaten über die Datenbank
  \end{itemize}
\end{block}

\begin{block}{Übergang von relationelem Schema zu SQL Schema}
  \begin{itemize}
    \item Name der Relation wird zum Tabellennamen
    \item Attribute werten untereinander geschrieben(Datentypen angeben)
    \item Bei einem Schlüssel \texttt{primary key} hinterschreiben
    \item Bei zusammengesetzten Schlüsseln \texttt{primary key (A, B)} angeben
    \item Für IDs ist \texttt{serial} als Datentyp sinnvoll
    \item Fremdschlüssel werden mit \texttt{foreign key} gekennzeichnet
  \end{itemize}
\end{block}
Beispiel:
\begin{itemize}
  \item \textbf{Student}(\underline{Matrikelnummer}, Name, Studiengang)
  \item \textbf{Kurs}(\underline{KursID}, Titel, Dozent)
  \item \textbf{Belegung}(\underline{Matrikelnummer}, \underline{KursID}, Note)
\end{itemize}
Wird folgendes SQL-Schema:
\begin{lstlisting}
-- Tabelle: Student
CREATE TABLE Student (
    Matrikelnummer INT PRIMARY KEY,
    Name VARCHAR(100),
    Studiengang VARCHAR(100)
);

-- Tabelle: Kurs
CREATE TABLE Kurs (
    KursID SERIAL PRIMARY KEY,
    Titel VARCHAR(100),
    Dozent VARCHAR(100)
);

-- Tabelle: Belegung
CREATE TABLE Belegung (
    Matrikelnummer INT,
    KursID INT,
    Note DECIMAL(3,1),
    PRIMARY KEY (Matrikelnummer, KursID),
    FOREIGN KEY (Matrikelnummer) REFERENCES Student(Matrikelnummer),
    FOREIGN KEY (KursID) REFERENCES Kurs(KursID)
);
\end{lstlisting}

\begin{block}{SQL als DML}
  \begin{itemize}
    \item Daten manipulieren und abfragen
    \item Es können Duplikate auftreten, falls nicht gewünscht \texttt{distinct} nutzen
  \end{itemize}
\end{block}

\begin{block}{Umsetzung der Operationen der relationalen Algebra in SQL}
  \begin{center}
    \begin{tabular}{|p{4cm}|p{7cm}|}
      \hline
      \textbf{Operation} & \textbf{SQL-Äquivalent} \\
      \hline
      Kartesisches Produkt & \texttt{select * from A, B;} \\
      \hline
      Join & \texttt{select * from A inner join b on <Bedingung>;} \\
      \hline
      Natürlicher Join & \texttt{select * from A natural join B;} \\
      \hline
      Outer Join & \texttt{select * from A left outer join B on <Bedingung>;} \\
      & man kann auch \texttt{right} oder \texttt{full} nutzen. \\
      \hline
      Join mit sich selber mit Alias & \texttt{select * from Angestellte A, Angestellte B where A.ID = B.Vorgesetzte;} \\
      \hline
      Hinweis & wenn zweimal ein gleichnamiges Attribut existiert, kann man mit z.B. A.ID und B.ID darauf zugreifen \\
      \hline
      Vereinigung & \texttt{select * from A union select * from B;} \\
      \hline
      Schnitt & \texttt{select * from A intersect select * from B;} \\
      \hline
      Differenz & \texttt{select * from A minus select * from B;} \\
      \hline
      \multicolumn{2}{|p{11cm}|}{Bei Vereinigung, Schnitt und Differenz werden Duplikate entfernt} \\
      \hline
    \end{tabular}
  \end{center}
\end{block}

\begin{block}{Datentypen in SQL}
  \begin{center}
    \begin{tabular}{|p{4cm}|p{7cm}|}
      \hline
      \textbf{Datentyp} & \textbf{Beschreibung} \\
      \hline
      \texttt{Integer/int, smallint} & Ganze Zahlen, smallint kleinere Zahlen ($\Rightarrow$ kleinerer Speicherbedarf) \\
      \hline
      \texttt{Float, Real, Double precision} & Gleitkommazahlen, Approximativ. Double precision für mehr Genauigkeit \\
      \hline
      \texttt{Decimal(i, j), Numeric(i, j)} & Feste Dezimalzahlen, i: Stellen insgesamt, j: Stellen nach dem Komma \\
      \hline
      \texttt{Serial} & Automatisch inkrementierende Ganzzahl, oft für Primärschlüssel \\
      \hline
      \texttt{Char(n), Varchar(n)} & Text, bei Char wird bei kürzerer Eingabe mit ' ' aufgefüllt, bei Varchar nicht \\
      \hline
      \texttt{create domain} & Definiert einen benutzerdefinierten Datentyp \\
      \hline
      Beispiel & Gibs nicht, ist mir zu blöd gerade? \\
      \hline
    \end{tabular}
  \end{center}
\end{block}

\end{document}