\documentclass{article}

\input{config.tex}

\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[width=0.3\textwidth]{Uni Logo.png} 
    \vspace*{2cm}
    
    {\Large\bfseries Datenbanken Zusammenfassung\par}
    \vspace{1.5cm}
    
    \textbf{Peter Minor}\\
    Sommersemester 2025
    
    \vfill    
    \vspace{1.5cm}
    {\large \today\par}
\end{titlepage}

\tableofcontents

\newpage
\section{Kapitel 1: Einführung}
Sehr viel Geyappe über Datenbanken und Entwurfsmodelle, später.

\section{Kapitel 2: Datenbank-Modellierung}

\begin{block}{Modell}
Ein Modell ist ein abstrahiertes Abbild der Realität. Es hilft beim Verständnis, bei der Kommunikation und Simulation komplexer Sachverhalte. In der Datenbankmodellierung wird zwischen konzeptuellen, logischen und physischen Modellen unterschieden.
\end{block}

\subsection*{Entity-Relationship-Modell (ER)}

\begin{block}{Entitätstyp}
Ein Entitätstyp (auch Objekttyp) ist eine Klasse gleichartiger Objekte. Darstellung im ER-Diagramm: Rechteck.
\end{block}

\begin{block}{Attribut}
Ein Attribut beschreibt eine Eigenschaft eines Entitätstyps. Darstellung: Ellipse. Attribute können einfach, zusammengesetzt, mehrwertig oder berechnet sein.
\end{block}

\begin{block}{Beziehungstyp (Relationship)}
Ein Beziehungstyp stellt eine Relation zwischen Entitäten dar. Darstellung: Raute. Die Kardinalität (1:1, 1:n, m:n) beschreibt die Anzahl möglicher Zuordnungen.
\end{block}

\begin{block}{Schlüssel}
Ein Schlüssel ist ein Attribut (oder eine Attributkombination), das jede Entität eindeutig identifiziert. Starke Entitäten haben eigene Schlüssel; schwache Entitäten benötigen eine identifizierende Beziehung zu einer starken Entität.
\end{block}

\begin{block}{Partizipation}
Beschreibt, ob eine Entität zwingend an einer Beziehung teilnehmen muss:
\begin{itemize}
  \item \textbf{totale Partizipation}: jede Entität muss beteiligt sein
  \item \textbf{partielle Partizipation}: Beteiligung ist optional
\end{itemize}
\end{block}

\begin{block}{Spezialisierung \& Generalisierung (EER)}
\begin{itemize}
  \item \textbf{Spezialisierung}: Zerlegung eines Supertyps in Subtypen
  \item \textbf{Generalisierung}: Vereinigung ähnlicher Entitätstypen zu einem Supertyp
\end{itemize}
\end{block}

\begin{center}
\begin{tikzpicture}[node distance=2cm, every node/.style={scale=0.85}]
  % Entity types
  \node[draw, rectangle] (Student) {Student};
  \node[draw, rectangle, right=5cm of Student] (Vorlesung) {Vorlesung};
  \node[draw, rectangle, above=3cm of Vorlesung] (Professor) {Professor};

  % Attributes
  \node[draw, ellipse, below=1.2cm of Student] (MatrNr) {MatrNr};
  \node[draw, ellipse, below left=1.2cm and 0.5cm of Student] (SName) {Name};

  \node[draw, ellipse, below=1.2cm of Vorlesung] (VorlNr) {VorlNr};
  \node[draw, ellipse, below right=1.2cm and 0.5cm of Vorlesung] (Titel) {Titel};

  \node[draw, ellipse, above left=1.2cm and 0.5cm of Professor] (PersNr) {PersNr};
  \node[draw, ellipse, above=1.2cm of Professor] (PName) {Name};

  % Relationship types
  \node[draw, diamond, below=0.8cm of $(Student)!0.5!(Vorlesung)$] (hoert) {hört};
  \node[draw, diamond, right=2cm of Professor] (liest) {liest};

  % Connections
  \draw (Student) -- (hoert);
  \draw (Vorlesung) -- (hoert);

  \draw (Professor) -- (liest);
  \draw (Vorlesung) -- (liest);

  \draw (Student) -- (MatrNr);
  \draw (Student) -- (SName);

  \draw (Vorlesung) -- (VorlNr);
  \draw (Vorlesung) -- (Titel);

  \draw (Professor) -- (PersNr);
  \draw (Professor) -- (PName);
\end{tikzpicture}
\end{center}

\section{Kapitel 3: Das relationale Datenmodell}

\begin{block}{Relation}
Eine Relation ist eine Tabelle mit Attributen (Spalten) und Tupeln (Zeilen). Sie basiert auf dem mathematischen Konzept einer Menge von Tupeln.
\end{block}

\begin{block}{Primärschlüssel}
Ein Attribut oder Attributkombination, die ein Tupel eindeutig identifiziert.
\end{block}

\begin{block}{Fremdschlüssel}
Ein Attribut, das auf den Primärschlüssel einer anderen Relation verweist und referentielle Integrität sicherstellt.
\end{block}

\subsection*{Relationale Algebra}

\begin{block}{Selektion ($\sigma$)}
Filtert Tupel, die eine bestimmte Bedingung erfüllen. Beispiel:
\[
\sigma_{Note \geq 4}(\text{Pruefungen})
\]
\end{block}

\begin{block}{Projektion ($\pi$)}
Reduziert die Anzahl der Attribute. Beispiel:
\[
\pi_{Name, MatrNr}(\text{Studierende})
\]
\end{block}

\begin{block}{Vereinigung $\cup$ Schnitt $\cap$ Differenz $-$}
Klassische Mengenoperationen für Relationen mit gleichem Schema.
\end{block}

\begin{block}{Kartesisches Produkt ($\times$)}
Kombiniert zwei Relationen durch paarweise Tupelkombination.
\end{block}

\begin{block}{Join ($\bowtie$)}
Verknüpft zwei Relationen über gemeinsame Attribute. Spezialformen:
\begin{itemize}
  \item natürlicher Join
  \item theta-Join
  \item equi-Join
\end{itemize}
\end{block}

\begin{block}{Umbenennung ($\rho$)}
Benennung einer Relation oder ihrer Attribute neu, z.B. zur besseren Lesbarkeit von Ausdrücken.
\end{block}


Beispielhafte Relationen:
\begin{itemize}
  \item \textbf{Student}(\underline{MatrNr}, Name)
  \item \textbf{Professor}(\underline{PersNr}, Name)
  \item \textbf{Vorlesung}(\underline{VorlNr}, Titel)
  \item \textbf{hört}(\underline{MatrNr}, \underline{VorlNr}) \\
        Fremdschlüssel: MatrNr $\rightarrow$ Student, VorlNr $\rightarrow$ Vorlesung
  \item \textbf{liest}(\underline{PersNr}, \underline{VorlNr}) \\
        Fremdschlüssel: PersNr $\rightarrow$ Professor, VorlNr $\rightarrow$ Vorlesung
\end{itemize}

\section{Kapitel 4: Relationale Entwurfstheorie}

\begin{block}{Funktionale Abhängigkeit}
Eine Attributmenge $\alpha$ bestimmt eine andere Attributmenge $\beta$, geschrieben als:
\[
\alpha \rightarrow \beta
\]
gilt genau dann, wenn für alle Tupel $t_1$, $t_2$ gilt: $t_1[\alpha] = t_2[\alpha] \Rightarrow t_1[\beta] = t_2[\beta]$
\end{block}

\begin{block}{Schlüssel und Superschlüssel}
\begin{itemize}
  \item \textbf{Superschlüssel:} $\alpha$ ist Superschlüssel, wenn $\alpha \rightarrow R$
  \item \textbf{Kandidatenschlüssel:} Minimaler Superschlüssel
\end{itemize}
\end{block}

\begin{block}{Ziel der Normalisierung}
Die Normalisierung dient dazu, Redundanzen zu vermeiden und Anomalien (Einfüge-, Update-, Löschanomalien) zu verhindern. Dazu wird ein Relationenschema anhand funktionaler Abhängigkeiten in wohldefinierte Formen überführt.
\end{block}

\begin{block}{Überblick über die Normalformen}
\begin{itemize}
  \item \textbf{1NF (erste Normalform):} 
    Alle Attributwerte sind atomar (nicht weiter teilbar).
  \item \textbf{2NF (zweite Normalform):} 
    1NF erfüllt + jedes Nicht-Schlüsselattribut ist voll funktional abhängig vom gesamten Primärschlüssel.
  \item \textbf{3NF (dritte Normalform):} 
    2NF erfüllt + keine transitiven Abhängigkeiten von Nicht-Schlüsselattributen.
  \item \textbf{BCNF (Boyce-Codd Normalform):} 
    Für jede nicht-triviale funktionale Abhängigkeit $\alpha \rightarrow \beta$ gilt: $\alpha$ ist ein Superschlüssel.
\end{itemize}
\end{block}

\begin{block}{Vorgehen zur Normalisierung}
\begin{enumerate}
  \item Ermittele alle funktionalen Abhängigkeiten (FDs).
  \item Bestimme alle Schlüsselkandidaten.
  \item Prüfe die aktuelle Normalform.
  \item Zerlege die Relation bei Verstoß in mehrere Relationen:
  \begin{itemize}
    \item Zerlege so, dass jede FD in einer Relation vollständig erfüllt wird.
    \item Erhalte dabei die Verlustfreiheit und Abhängigkeitserhaltung.
  \end{itemize}
\end{enumerate}
\end{block}

\begin{block}{Beispiel: Normalisierung auf 3NF}
Gegeben sei folgende Relation:
\[
R(\underline{MatrNr}, Name, Studiengang, Fakultaet)
\]
mit den funktionalen Abhängigkeiten:
\begin{align*}
\text{F1: } & \text{MatrNr} \rightarrow \text{Name, Studiengang, Fakultaet} \\
\text{F2: } & \text{Studiengang} \rightarrow \text{Fakultaet}
\end{align*}

\textbf{Analyse:}
\begin{itemize}
  \item F1: MatrNr ist ein Schlüsselkandidat.
  \item F2: transitive Abhängigkeit: MatrNr $\rightarrow$ Studiengang $\rightarrow$ Fakultaet
  \item $\Rightarrow$ Verstoß gegen 3NF.
\end{itemize}

\textbf{Zerlegung in 3NF:}
\begin{itemize}
  \item $R_1(\underline{MatrNr}, Name, Studiengang)$
  \item $R_2(\underline{Studiengang}, Fakultaet)$
\end{itemize}

\textbf{Ergebnis:} Beide Relationen sind in 3NF, keine Redundanz, keine Anomalien.
\end{block}

\begin{block}{Anomalien}
Anomalien treten auf, wenn Relationen schlecht strukturiert sind – meist durch Redundanz und fehlende Trennung von unabhängigen Daten. Es gibt drei Hauptarten:
\begin{itemize}
  \item \textbf{Einfügeanomalie:} Daten können nicht eingefügt werden, ohne andere zu erzeugen
  \item \textbf{Updateanomalie:} Inkonsistenz bei mehrfacher Speicherung derselben Information
  \item \textbf{Löschanomalie:} Verlust nützlicher Informationen durch Löschung eines Tupels
\end{itemize}
\end{block}

\section{Kapitel 5: SQL - Structured Query Language}

Wir befinden uns in der Datenbank-Installation, also im Physischen Schemaentwurf.

\begin{block}{Historie}
  \begin{itemize}
    \item 1974: SEQUEL von IBM, Implementierung für System R
    \item 1983: SQL ist der Standard geworden
    \item 1986: SQL-86, bzw. SQL 1 $\Rightarrow$ erster ANSI und ISO-Standard
    \item 1992: SQL 2, deutliche Erweiterungen im Standard
    \item Weitere Revisionen:2000(SQL 3), 2003, 2006, 2008, 2011, 2016, 2023
  \end{itemize}
\end{block}

SQL dient als verschiedene Sprachen:
\begin{itemize}
  \item VDL, DDL, SDL zur Definition von Datenbanken
  \item DML(Datenmanipulationssprache), DCL(Datenkontrollsprache) zum Zugriff auf Datenbanken
\end{itemize}
SQL-Befehle:
\begin{center}
  \begin{longtable}{|p{4cm}|p{7cm}|}
    \hline
    \textbf{Befehl} & \textbf{Beschreibung} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DDL(Datendefinition)} \\
    \hline
    \texttt{CREATE SCHEMA} & Erstellt ein neues Schema in der Datenbank. \\
    \hline    
    Beispiel & \texttt{create schema Unternehmen authorization JSmith create table Projekt;} \\
    \hline
    Einfacher: & \texttt{PID int not null primary key,} \\
    & geht aber leider nicht mit zusammengesetzten Schlüsseln. \\
    \hline
    \texttt{CREATE Table} & Erstellt eine neue Tabelle im Schema. \\
    \hline
    Beispiel & \texttt{create table Projekt (} \\ & \texttt{PID int not null,} \\ & \texttt{Name varchar(50) not null, } \\ & \texttt{primary key(PID));} \\
    \hline
    \texttt{ALTER Table} & ändert die angegebene Tabelle. \\
    \hline
    \multicolumn{2}{|p{11cm}|}{Es gibt noch andere Verwendungen für \texttt{alter:}} \\
    \texttt{alter database} & ändert Eigenschaften der Datenbank. \\
    \texttt{alter view} & ändert die Definition einer Sicht \\
    \texttt{alter index} & modifiziert einen Index \\
    \texttt{alter user/role} & ändert die Rollen eines Benutzers \\
    \hline
    \texttt{Add} & Fügt eine Spalte zu einer Tabelle hinzu \\
    \hline
    Beispiel & \texttt{alter table Angestellte} \\
    & \texttt{ add foreign key (Abt) references Abteilung(Nummer);} \\
    \hline
    \texttt{drop} & Löscht das angegebene Objekt. Kann auf Schemen, Tabellen, Sichten, Constraints und Spalten angewendet werden. \\
    \hline
    Beispiel & \texttt{drop table Arbeitszeiten;} \\
    \hline
    \texttt{rename} & Ändert den Namen einer Tabelle \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DML(Datenmanipulation und -abfrage)} \\
    \hline
    \texttt{select [..] from} & Wählt die gegebenen Spalten aus der Tabelle aus und gibt sie zurück \\
    \hline
    \multicolumn{2}{|p{11cm}|}{Durch z.B. \texttt{select 1.1*Gehalt} kann man Spaltenwerte in der Ausgabe anpassen.} \\
    \multicolumn{2}{|p{11cm}|}{Gleiches funktioniert mit +,- und / auf Zahlen.} \\
    \multicolumn{2}{|p{11cm}|}{Für Konkatinieren von Zeichenketten verwendet man \texttt{||}.} \\
    \hline
    \texttt{insert into} & fügt ein neues Tupel in eine Tabelle ein \\
    & überprüft automatisch die Vorgaben der Datenbank und weist ggf. zurück \\
    \hline
    Beispiel & \texttt{insert into Student (MNr, VName, NName, Fach) values (123456, 'Max', 'Mustermann', 'Informatik');} \\
    & Alle nicht angegebenen Infos werden zu NULL bzw. default. Bei SERIAL wird automatisch eingefügt. \\
    \hline
    \texttt{delete from [..]} & Löscht Tupel aus der angegebenen Tabelle. Where bestimmt, was gelöscht werden soll. \\
    & überprüft automatisch die Vorgaben der Datenbank und weist ggf. zurück \\
    \hline
    \texttt{update [..] set [..]} & setzt bei den Tupeln der Tabelle Attributwerte. \\
    &  kann mit where spezifiziert werden. \\
    \hline
    \texttt{merge into[..] using [..]} & Fügt zwei Tabellen zusammen, die gleiche Attribute erwarten. \\
    &  Durch \texttt{when matched} bzw. \texttt{when not matched} kann das Verhalten beim mergen bestimmt werden. \\
    \hline
    Beispiel & \texttt{merge into AllStudent c using Student a on AllStudent.MNr = Student.MNr} \\
    & \texttt{when matched then update set c.VName = a.VName, c.NName = a.NName...} \\
    & \texttt{when not matched then insert values (a.MNr, a.VName, a.NName, a.Fach);} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als VCL(Sichtendefinition)} \\
    \hline
    \texttt{create view [..] as select [..]} & Erstellt eine Sicht, die aus der Select-Abfrage resultiert. \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DCL(Rechteverwaltung)} \\
    \hline
    \texttt{grant [..] on [..] to} &  Gibt das spezifitierte Recht an der spezifizierten Tabelle an die spezifizierten Nutzer.\\
    \hline
    \texttt{revoke [..] on [..] from} & Entzieht das spezifitierte Recht an der spezifizierten Tabelle von den spezifizierten Nutzern. \\
    \hline
  \end{longtable}
\end{center}
SQL-Keywords:
\begin{center}
  \begin{longtable}{|p{4cm}|p{7cm}|}
    \hline
    \textbf{Keyword} & \textbf{Beschreibung} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{SQL als DDL(Datendefinition)} \\
    \hline
    \texttt{not null} & Attribut darf nicht leer sein. \\
    \hline
    \texttt{primary key} & Attribut ist Primärschlüssel der Tabelle. \\
    \hline
    \texttt{unique} & Attributwerte müssen eindeutig sein. \\
    \hline
    \texttt{check} & Ermöglicht komplexere Einschränkungen \\
    \hline
    \texttt{cascade} & ? \\
    \hline
    \texttt{set null} & Setzt die Referenz auf null \\
    \hline
    \texttt{set default} & Setzt die Referenz auf den Default-Wert \\
    \hline
    \texttt{No Action/Restrict} & ? \\
    \hline
    Beispiel & Constraints beispiel? \\
    \hline
    \texttt{foreign key} & Attribut verweist auf Primärschlüssel einer anderen Tabelle. \\
    \hline
    \texttt{references} & Definiert die referenzierte Tabelle und Spalte für den Fremdschlüssel. \\
    \hline
    Beispiel: & \texttt{foreign key (PID) references Projekt(PID)} \\
    \hline
    \texttt{to\_number} oder \texttt{to\_char} & Konvertiert Datentypen, z.B. von String zu Zahl oder umgekehrt. \\
    \hline
    Date, Time, Datetimeoffset, interval, year, day, second? & \\
    \hline
    \texttt{where} & filtert nach Bedingungen \\
    \hline
    Beispiel & \texttt{select * from Klausur where Note <= 4;} \\
    \hline
    \texttt{having} & filtert nach Bedingungen, nur auf Gruppen. Tritt nur zusammen mit \texttt{Group by} auf \\
    \hline
    Beispiel & \texttt{select * from Projekt, ArbeitetAn where Nummer = projNr group by Nummer, Name having count(*) > 2} \\
    \hline
    \texttt{and} & Verknüpft Bedingungen, alle müssen erfüllt sein \\
    \hline
    \texttt{or} & Verknüpft Bedingungen, mindestens eine muss erfüllt sein \\
    \hline
    \texttt{in} & Überprüft, ob ein Wert in einer Liste von Werten enthalten ist \\
    \hline
    Beispiel & \texttt{select * from Student where Durchschnittsnote in (0.7, 1.0, 1.7, 2.0);} \\
    \hline
    \texttt{order by} & Sortiert die Ergebnisse nach den angegebenen Spalten \\
    \hline
    \texttt{Asc} bzw. \texttt{desc} & Sortiert aufsteigend bzw. absteigend, Asc ist der Standardwert \\
    \hline
    Beispiel & \texttt{select * from Klausur order by Note desc;} \\
    \hline
    \texttt{group by} & Gruppiert die Ergebnisse nach den angegebenen Spalten \\
    \hline
    Beispiel & \texttt{select * from Belegung group by KursID;} \\
    \hline
    \texttt{distinct} & Entfernt doppelte Einträge aus dem Ergebnis \\
    & Aber ist teuer und braucht man nicht unbedingt.\\
    \hline
    Beispiel & \texttt{select distinct Alter from Student;} \\
    \hline
    \texttt{as} & Benennt die Spalte um \\
    Beispiel & \texttt{select Name as StudentName from Student;} \\
    & Auf Aliasse der äußeren Anfrage kann man innen zugreifen, anders herum aber nicht. \\
    \hline
    \texttt{count} & Zählt die Anzahl der Tupel \\
    \hline
    \texttt{sum} & Summe der Werte der Tupelattribute \\
    \hline
    \texttt{min} & kleinstes Tupelattribut \\
    \hline
    \texttt{max} & größtes Tupelattribut \\
    \hline
    \texttt{avg} & durschschnittlicher Wert der Tupelattribute \\
    \hline
    Beispiel & \texttt{select max(Gehalt) from Angestellte;} \\
    \hline
    \multicolumn{2}{|p{11cm}|}{In Kombination mit \texttt{group by} werden die Operationen \texttt{count, sum, min, max} und \texttt{avg} jeweils auf die einzelnen Gruppen angewendet.} \\
    \hline
    \texttt{like} & Vergleicht Zeichenketten \\
    \hline
    Beispiel & \texttt{select * from Student where Name like 'T \_ \_';} \\
    & sucht alle Studierenden raus, die einen Namen mit drei Buchstaben haben, der mit T anfängt\\
    & \texttt{select * from Student where Name like 'T\%';} \\
    & sucht alle Studierenden raus, die einen Namen haben, der mit T anfängt \\
    \hline
    \texttt{between} & Überprüft, ob ein Wert in einem Intervall liegt \\
    \hline
    \texttt{exists} & Überprüft, ob das Ergebnis einer Unterabfrage nicht leer ist \\
    \hline
    \texttt{not} & Negiert eine Bedingung \\
    \hline
    \texttt{unique} & überprüft, ob eine Multimenge Duplikate enthält \\
    \hline
    \texttt{is null} bzw. \texttt{is not null} & Überprüft, ob ein Attributwert NULL ist. = NULL ist nicht möglich! \\
    \hline
  \end{longtable}
\end{center}

\begin{block}{SQL als DDL}
  \begin{itemize}
    \item Schema, Tabellen, Datentypen, Constraints definieren
    \item Strukturelle Änderungen mittels \texttt{drop}, \texttt{alter}
    \item SCHEMA:
    \begin{itemize}
      \item Namensraum in DB
      \item Hat eindeutigen Namen
      \item Hat Autorisierungsbezeichner
      \item Beschreibt jedes im Schema enthaltene Objekt
      \begin{itemize}
        \item Relationen
        \item Wertebereiche
        \item Restriktionen
        \item Sichten
        \item Zugriffsrechte
      \end{itemize}
    \end{itemize}
    \item \texttt{information\_schema} enthält Metadaten über die Datenbank
  \end{itemize}
\end{block}

\begin{block}{Übergang von relationelem Schema zu SQL Schema}
  \begin{itemize}
    \item Name der Relation wird zum Tabellennamen
    \item Attribute werten untereinander geschrieben(Datentypen angeben)
    \item Bei einem Schlüssel \texttt{primary key} hinterschreiben
    \item Bei zusammengesetzten Schlüsseln \texttt{primary key (A, B)} angeben
    \item Für IDs ist \texttt{serial} als Datentyp sinnvoll
    \item Fremdschlüssel werden mit \texttt{foreign key} gekennzeichnet
  \end{itemize}
\end{block}
Beispiel:
\begin{itemize}
  \item \textbf{Student}(\underline{Matrikelnummer}, Name, Studiengang)
  \item \textbf{Kurs}(\underline{KursID}, Titel, Dozent)
  \item \textbf{Belegung}(\underline{Matrikelnummer}, \underline{KursID}, Note)
\end{itemize}
Wird folgendes SQL-Schema:
\begin{lstlisting}
-- Tabelle: Student
CREATE TABLE Student (
    Matrikelnummer INT PRIMARY KEY,
    Name VARCHAR(100),
    Studiengang VARCHAR(100)
);

-- Tabelle: Kurs
CREATE TABLE Kurs (
    KursID SERIAL PRIMARY KEY,
    Titel VARCHAR(100),
    Dozent VARCHAR(100)
);

-- Tabelle: Belegung
CREATE TABLE Belegung (
    Matrikelnummer INT,
    KursID INT,
    Note DECIMAL(3,1),
    PRIMARY KEY (Matrikelnummer, KursID),
    FOREIGN KEY (Matrikelnummer) REFERENCES Student(Matrikelnummer),
    FOREIGN KEY (KursID) REFERENCES Kurs(KursID)
);
\end{lstlisting}

\begin{block}{SQL als DML}
  \begin{itemize}
    \item Daten manipulieren und abfragen
    \item Es können Duplikate auftreten, falls nicht gewünscht \texttt{distinct} nutzen
    \item Es wird zuerst Join dann Gruppierung und dann Aggregation durchgeführt
    \item Abfragen können auch Unterabfragen enthalten, also verschachtelt sein.
  \end{itemize}
\end{block}

\begin{block}{Umsetzung der Operationen der relationalen Algebra in SQL}
  \begin{center}
    \begin{tabular}{|p{4cm}|p{7cm}|}
      \hline
      \textbf{Operation} & \textbf{SQL-Äquivalent} \\
      \hline
      Kartesisches Produkt & \texttt{select * from A, B;} \\
      \hline
      Join & \texttt{select * from A inner join b on <Bedingung>;} \\
      \hline
      Natürlicher Join & \texttt{select * from A natural join B;} \\
      \hline
      Outer Join & \texttt{select * from A left outer join B on <Bedingung>;} \\
      & man kann auch \texttt{right} oder \texttt{full} nutzen. \\
      \hline
      Join mit sich selber mit Alias & \texttt{select * from Angestellte A, Angestellte B where A.ID = B.Vorgesetzte;} \\
      \hline
      Hinweis & wenn zweimal ein gleichnamiges Attribut existiert, kann man mit z.B. A.ID und B.ID darauf zugreifen \\
      & Auf Aliasse der äußeren Anfrage kann man innen zugreifen, anders herum aber nicht. \\
      \hline
      Vereinigung & \texttt{select * from A union select * from B;} \\
      \hline
      Schnitt & \texttt{select * from A intersect select * from B;} \\
      \hline
      Differenz & \texttt{select * from A minus select * from B;} \\
      \hline
      \multicolumn{2}{|p{11cm}|}{Bei Vereinigung, Schnitt und Differenz werden Duplikate entfernt} \\
      \hline
    \end{tabular}
  \end{center}
\end{block}

\begin{block}{SQL als VDL(Verwaltung der Sichten)}
  Eine Sicht ist eine virtuelle Tabelle, die aus einer Abfrage resultiert.
  \begin{itemize}
    \item Können, müssen aber nicht in der Datenbank gespeichert werden
    \item Werden immer aktuell gehalten
    \item Können wie Tabellen abgefragt werden
    \item Manipulation oft nicht möglich(non-updatable views)
  \end{itemize}
\end{block}

\begin{block}{SQL als DCL(Verwaltung der Zugriffsrechte)}
  \begin{itemize}
    \item \texttt{grant} und \texttt{revoke} für Rechteverwaltung
    \item Rechte können auf Objekte wie Tabellen, Sichten, Prozeduren angewendet werden
    \item Rechte: SELECT, INSERT, UPDATE, DELETE, EXECUTE
    \item Beispiel: \texttt{grant select on Tabelle to Benutzer;}
  \end{itemize}
\end{block}

\begin{block}{Datentypen in SQL}
  \begin{center}
    \begin{tabular}{|p{4cm}|p{7cm}|}
      \hline
      \textbf{Datentyp} & \textbf{Beschreibung} \\
      \hline
      \texttt{Integer/int, smallint} & Ganze Zahlen, smallint kleinere Zahlen ($\Rightarrow$ kleinerer Speicherbedarf) \\
      \hline
      \texttt{Float, Real, Double precision} & Gleitkommazahlen, Approximativ. Double precision für mehr Genauigkeit \\
      \hline
      \texttt{Decimal(i, j), Numeric(i, j)} & Feste Dezimalzahlen, i: Stellen insgesamt, j: Stellen nach dem Komma \\
      \hline
      \texttt{Serial} & Automatisch inkrementierende Ganzzahl, oft für Primärschlüssel \\
      \hline
      \texttt{Char(n), Varchar(n)} & Text, bei Char wird bei kürzerer Eingabe mit ' ' aufgefüllt, bei Varchar nicht \\
      \hline
      \texttt{create domain} & Definiert einen benutzerdefinierten Datentyp \\
      \hline
    \end{tabular}
  \end{center}
\end{block}

\subsection*{Programmiermethoden in SQL}
\begin{block}{Zugriff auf die DB}
  Der Zugriff auf die Datenbank kann von verschiedenen Gruppen erfolgen:
  \begin{itemize}
    \item Administratoren: Die Befehle von den Administratoren werden in der Regel direkt auf der Datenbank ausgeführt.
    \item Anwendungen: Anwendungen nutzen in der Regel eine Schnittstelle (API) der Datenbank, um auf sie zuzugreifen.
    \item Gelegentliche Nutzer: Die Befehle von gelegentlichen Nutzern werden in der Regel über eine interaktive Anfrage passieren, die erst einen Übersetzer durchlaufen, um dann auf der Datenbank ausgeführt zu werden.
  \end{itemize}
\end{block}

\begin{block}{SQL-Programmiermethoden}
  Es gibt mehrere Möglichkeiten, wie ein Anwendungsprogramm auf eine Datenbank zugreifen kann:
  \begin{itemize}
    \item Direkter Aufruf
    \begin{itemize}
      \item Aufruf von SQL-Befehlen direkt im Programm
    \end{itemize}
    \item Embedded/Dynamic SQL
    \begin{itemize}
      \item SQL Wird in die Programmiersprache eingebettet
      \item SQL-Befehle werden dynamisch zur Laufzeit generiert
    \end{itemize}
    \item Module Language
    \begin{itemize}
      \item SQL wird in Module ausgelagert, die in der Programmiersprache aufgerufen werden
    \end{itemize}
    \item Call-Level APIs
    \begin{itemize}
      \item Standardisierte Schnittstellen (z.B. ODBC, JDBC) für den Datenbankzugriff
      \item Der Programmierer sieht kein SQL mehr (Mappings)
    \end{itemize}
  \end{itemize}
\end{block}

\begin{block}{impedance mismatch}
  \begin{itemize}
    \item Relationales Modell wird von objektorientieren Programmiersprachen nicht unterstützt
    \item SQL basiert auf Mengen, OO-Programmiersprachen auf Objekten
    \item Keine Pointer o.Ä.
    \item Lösung: Embedded SQL
  \end{itemize}
\end{block}

\begin{block}{Embedded SQL}
  \begin{itemize}
      \item Problem wird (teilweise) umgangen, indem Variablen zwischen SQL und der Programmiersprache 'geteilt' werden
      \item \texttt{exec sql begin declare section;} bzw. \texttt{[..]end[..];}
      \item Darin können Variablen deklariert werden:
      \item \texttt{char var1[20]; int var2;}
      \item Dann kann in die Variablen geschrieben werden:
      \item \texttt{exec sql insert into [..] values (:var1, :var2);}
      \item Außerdem kann gelesen werden:
      \item \texttt{exec sql select [..] into :var1 from [..];}
      \item Variable \texttt{SQLSTATE} enthält den Status der letzten SQL-Anweisung und ggf. Fehlercodes
    \end{itemize}
\end{block}

\begin{block}{Cursor in Embedded SQL}
  Trotzdem bleibt bestehen: Das Ergebnis von SQL-Abfragen sind meistens Mengen. Lösung: Cursors
  \begin{itemize}
    \item Cursors sind Zeiger auf eine Ergebnismenge
    \item Sie ermöglichen es, durch die Ergebnismenge zu iterieren
    \item Beispiel:
    \begin{lstlisting}
    exec sql begin declare section;
    char var1[20];
    char SQLSTATE[6];
    exec sql end declare section;
    exec sql declare c1 cursor for select VName
                              from Student;
    exec sql open c1;
    while(true) {
        exec sql fetch c1 into :var1;
        if (SQLSTATE == '02000') break;
        // Verarbeite var1
    }
    exec sql close c1;
    \end{lstlisting}
  \end{itemize}
\end{block}
Ursprünglich wurde für Java SQLJ benutzt, mittlerweile ist das aber veraltet.
\begin{block}{Dynamic SQL}
  \begin{itemize}
    \item Standard für dynamische SQL-Abfragen in Programmen
    \item Also keine Deklaration vorab
    \item Zwei Möglichkeiten:
    \item Execute Immediate: Direkte Ausführung eines SQL-Befehls
    \item Prepare and Execute: SQL-Befehl wird vorbereitet und dann (mehrfach) ausgeführt
    \item Großer Nachteil: SQL Injection möglich, wenn nicht richtig abgefangen wird
  \end{itemize}
\end{block}

\begin{block}{Module Language}
  \begin{itemize}
    \item Trennung von SQL und Anwendungsprogramm
    \item Modul enthält SQL-Befehle und Deklarationen
    \item Anwendungsprogramm ruft Modul auf
  \end{itemize}
\end{block}

\begin{block}{Call-Level APIs}
  \begin{itemize}
    \item Standardisierte Schnittstellen für den Datenbankzugriff
    \item Beispiel: ODBC, SQL/CLI, JDBC
    \item Programmierer sieht kein SQL mehr, sondern nur die API-Funktionen
    \item Mappings zwischen Objekten und Relationen
  \end{itemize}
\end{block}

\begin{block}{ORM: Mappings zwischen Objekten und Relationen}
  \begin{itemize}
    \item Alles nicht perfekt, da Objekte und Relationen unterschiedliche Konzepte sind
    \item ORM (Object-Relational Mapping) versucht, diese Lücke zu schließen
    \item Mappings zwischen Objekten und Relationen
    \item Framework verbirgt SQL komplett und bietet objektorientierte API
  \end{itemize}
\end{block}

\section{Kapitel 6: Anfrageverarbeitung}

\begin{block}{Motivation}
  \begin{itemize}
    \item DBMS muss viele Anfragen möglichst schnell und minimalen Ressourcen verarbeiten
    \item $\Rightarrow$ effiziente Anfrageverarbeitung notwendig
  \end{itemize}
\end{block}

\begin{block}{DBMS Aufbau}
  \begin{itemize}
    \item Zuerst gehen die Anfragen an die Anfrageverarbeitung, die aus einem Operator-Evaluierer und einem Optimierer besteht
    \item Danach durchlaufen sie die Speicherung, zuerst die Dateiverwaltungs- und Zugriffsmethoden
    \item Danach den Puffer-Verwalter und den Verwalter für externen Speicherbedarf
    \item Diese Interagieren mit dem Transaktionsmanagement, das aus einem Transaktionsverwalter, einem Sperrverwalter und einem Wiederherstellungsverwalter besteht
    \item Danach geht die Anfrage an die Datenbank, die in der Realität aus Dateien und Daten und Indices besteht
  \end{itemize}
  Schaubild Kapitel 6, Seite 4
  \begin{itemize}
    \item Die Verwaltung eines DBMS ähnelt sehr der eines Betriebssystems, daher
    \item schaltet es häufig Betriebsdienstsysteme aus, um gegenseitige Störungen zu verhindern
    \item Das DBMS weiß mehr über die Zugriffsmuster, was Prefetching(s.u. In der Praxis) ermöglicht
  \end{itemize}
\end{block}

\subsection*{Speicherung}

\begin{block}{Speicherung}
  \begin{itemize}
    \item In großen Datenbanken sind die Daten zu groß, um in den Hauptspeicher zu passen
    \item Speicherung soll eine große Menge an Speicherplatz liefern
    \item Dabei  soll der Zugriff für möglichst geringe Kosten möglichst schnell sein
    \item Die Daten sollen gesichtert sein, Verlust der Daten ist nicht akzeptabel
    \item In einem normalen Computer wird das folgendermaßen umgesetzt:
    \begin{tabular}{|p{4cm}|p{3cm}|p{2cm}|}
      \hline
      \textbf{Speichertyp} & \textbf{Kapazität} & \textbf{Latenz} \\
      \hline
      CPU(Register) & Bytes & < 1 ns \\
      \hline
      Cache-Speicher & Kilo-/Megabytes & < 10 ns \\
      \hline
      Hauptspeicher(RAM) & Gigabytes & 20-100 ns \\
      \hline
      Flash-Speicher/SSD & Terabytes & 30-250 $\mu$s \\
      \hline
      Festplatte/HDD & Tera-Petabytes & 3-10ms \\
      \hline
      Bandautomat & Petabytes & variiert \\
      \hline
    \end{tabular}
  \end{itemize}
\end{block}

\begin{block}{Magnetische (Fest-)Platten}
  \begin{itemize}
    \item Arme werden auf bestimmte Spur bewegt, Platte dreht konstant
    \item Spur: Kreis auf de Oberfläche der Platte
    \item Sektor: Eine Spur wird in Sektoren unterteilt, die kleinste adressierbare Einheit
    \item Block: Mehrere Sektoren zusammen in eine logische Einheit gefasst
    \item Zugriffszeit besteht aus:
    \begin{itemize}
      \item Suchzeit $t_s$: Zeit, um den Arm auf die richtige Spur zu bewegen
      \item Wartezeit $t_r$: Zeit, bis der Block unter dem Lesekopf ist
      \item Lese- bzw. Schreibzeit $t_{tr}$
      \item Gesamte Zugriffszeit $t_a = t_s + t_r + t_{tr}$
    \end{itemize}
    \item Sequentieller Zugriff, bei dem die Blöcke direkt hintereinander liegen ist schneller als Wahlfreier Zugriff
    \item Sehr viel schneller.
  \end{itemize}
\end{block}

\begin{block}{Speichernetzwerk(SAN)}
  \begin{itemize}
    \item Speichernetzwerk, das aus mehreren Festplatten bzw. Servern mit jeweils mehreren Festplatten besteht
    \item Zeigt sich aber als 'logische Platten' an das DBMS
    \item Vorteile: Hardwarebeschleunidung, Redundanz(Fehlertoleranz), einfachere Verwaltung, Flexibilität
    \item Alternativ: Cloud-Speicher, der über das Internet zugänglich ist
    \item System kostet mehr und ist Langsamer(Redundanz von bis zu 1s), aber ist zuverlässiger
  \end{itemize}
\end{block}

\subsection*{Verwaltung}

\begin{block}{Abstrahierung der Technischen Details vom Speicher(Seiten)}
  \begin{itemize}
    \item Eine 'Seite' ist eine logische Speichereinheit(4-64 KB) für die Restlichen Komponenten
    \item Die Seitennummer weist auf die physische Adresse der Seite hin
    \begin{itemize}
      \item Betriebssystemdatei inkl. Versatz
      \item Kopf-Sektor-Spur von Festplatte
      \item Angabe für ein Bandgerät und -nummer inkl. Versatz
    \end{itemize}
  \end{itemize}
\end{block}

\begin{block}{leere Seiten}
  \begin{itemize}
    \item \texttt{insert} sucht leere Seite zum Einfügen
    \item \texttt{delete} gibt die Seite wieder frei
    \item Leere Seiten müssen Persistenz gespeichert werden
    \begin{itemize}
      \item Als Liste von leeren Seiten(Hinzufügen, wenn Seite leer wird, entfernen, wenn Seite alloziert wird)
      \item Als Bitmap, Bit p wird umgeklappt, wenn die Seite (de-)alloziert wird
    \end{itemize}
  \end{itemize}
\end{block}

\subsection*{Puffer}
\begin{block}{Puffer-Verwalter}
  \begin{itemize}
    \item Vermittelt zwischen externem Speicher(Festplatten etc) und internem Speicher(Hauptspeicher)
    \item Verwaltet Teil des Hauptspeichers(buffer pool)
    \item Externe Seiten werden in den Puffer geladen
    \item \texttt{pin} und \texttt{unpin}, um Seiten anzufordern und freizugeben
    \item Hier wird die Seitennummer angegeben und beim freigeben auch, ob die Seite bearbeitet wurde
    \item Wenn die Seite bereits im Puffer ist, wird direkt die Referenz zurückgegeben
    \item Wenn die Seite nicht im Puffer ist, wird sie geladen und die Referenz zurückgegeben
    \item Es wird gespeichert, wie oft eine Seite angefordert wurde, damit benutze Seiten immer im Puffer bleiben
    \item Wenn der Puffer voll ist, muss eine Ersetzungsstrategie angewendet werden
  \end{itemize}
\end{block}

\begin{block}{Ersetzungsstrategien}
  Es wird ausgewählt, welche Seite aus dem Puffer entfernt wird, wenn eine neue Seite geladen werden soll.
  \begin{itemize}
    \item LRU: Seite mit dem am längsten zurückliegenden unpin
    \item LRU-k: k-letztes unpin, sonst wie LRU
    \item MRU: Seite mit dem jüngsten unpin
    \item Random: Zufällige Seite
    \item [..]
  \end{itemize}
  Problem: Seite muss Pincount = 0 haben, aber was ist, wenn es eine solche Seite nicht gibt?
\end{block}

\begin{block}{In der Praxis}
  \begin{itemize}
    \item Anfragen werden 'vorhergesagt', Seiten werden im Puffer gehalten, wenn sie wahrscheinlich benötigt werden(Prefetching)
    \item Fixierungs- und Verdrängungsempfehlungen von höherem Code, wenn dieser Weiß, dass eine Seite länger benötigt wird oder wahrscheinlich nicht mehr
  \end{itemize}
\end{block}

\subsection*{Zugriff}
\begin{block}{Datenbank-Dateien}
  \begin{itemize}
    \item Der Inhalt von Seiten ist für die Seitenverwaltung nicht relevant
    \item DBMS verwaltet die Tabellen von Tupeln, Indexstrukturen, ...
    \item Eine Datei besteht aus einer oder mehreren Seiten
    \item jede Seite speichert einen oder mehrere Datensätze
    \item Ein Datensatz entspricht einem Tupel
  \end{itemize}
\end{block}

\begin{block}{Heap-Dateien}
  \begin{itemize}
    \item Datensätze werden in willkürlicher$^*$ Ordnung gespeichert
    \item Umsetzung: Verkettete Liste von Seiten, Problem: Man muss viele Seiten durchsuchen(und auch Laden), bis die richtige Seite gefunden wurde
    \item Alternative: Verzeichnis von Seiten, ist mit Zusatzaufwand für das Verzeichnis verbunden
  \end{itemize}
  $^*$Bei der Speicherung von Datensätzen gibt es mehrere Möglichkeiten, die 'richtige' Seite zu finden:
  \begin{tabular}{|p{4cm}|p{6.5cm}|}
    \hline
    \textbf{Methode} & \textbf{Beschreibung} \\
    \hline
    Append only & Datensatz wird immer an die aktuelle Seite angefügt, wenn diese voll ist, wird eine neue Seite angelegt. \\
    \hline
    Best-fit & Datensatz wird auf die Seite geschrieben, wo die 'kleinste Lücke' ist, in die der Satz noch passt \\
    & man muss erst alle Seiten durchsuchen, um die beste zu finden \\
    \hline
    First-fit & Datensatz wird auf die erste Seite geschrieben, wo genug Platz ist \\
    \hline
    Next-fit & Wie first-fit, aber die Suche beginnt bei der letzten einfügeoperation \\
    \hline
  \end{tabular}
\end{block}

\begin{block}{Inhalt einer Seite}
  \begin{itemize}
    \item Jeder Datensatz hat eine Datensatz-Kennung, die genau beschreibt, wo sich dieser befindet
    \item Typisch: Seitennummer und Slot, Slots beginnen bei 0, mit fester Slotgröße
    \item Suche dann innerhalb der Seite mit \texttt{slotnr * slotsize}
    \item Die Seite hat einen Header, der mit einer Bitmap markiert, welche Slots belegt bzw. gültig sind
    \item Löschung eines Datensatzes: Slot wird als ungültig markiert, die Datensatz-Kennung ändert sich nicht
    \item Ggf. haben Datensätze unterschiedliche Längen, diese werden dann ans Ende der Seite gepackt und ein Slot-Verzeichnis wird verwendet
    \item Das Verzeichnis enthält die Startadresse und Länge jedes Datensatzes
    \item Dadurch kann die Datensatz-Kennung auf die Adresse im Slot-Verzeichnis zeigen und das Feld auf der Seite verschoben werden, ohne dass sich die Kennung ändert
    \item Das Slot-Verzeichnis wird am Anfang der Seite gespeichert
  \end{itemize}
\end{block}

\begin{block}{Alternative Seiteneinteilung}
  \begin{itemize}
    \item Row-Store:
    \begin{itemize}
      \item Tupel werden immer zusammen gespeichert
      \item Vorteil: Schneller Zugriff auf komplette Tupel, vor allem bei \texttt{select * from Student where Name = 'Max';} sinnvoll
    \end{itemize}
    \item Column-Store:
    \begin{itemize}
      \item Es wird immer ein Attribut zusammen gespeichert, dafür dann für alle Tupel
      \item Vorteil: Schneller Zugriff auf einzelne Attribute, vor allem bei \texttt{select avg(Note) from Klausur;} sinnvoll
    \end{itemize}
  \end{itemize}
  Diese Konzepte lassen sich auch kompinieren.
\end{block}
\end{document}